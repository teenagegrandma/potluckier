/**
 * Build client request impelements, Inspired by npm request.js
 * @author Allex Wang (allex.wxn@gmail.com)
 */

module.exports = regRequest;

var url = require('url')
  , zlib = require('zlib')
  , Stream = require('stream').Stream
  , request = require('request')
  , crypto = require('crypto')
  ;

// 1. https
// 2. send authorization
// 3. content-type is 'application/json' -- metadata
function regRequest (method, uri, options, cb_) {
  options = options || {}

  var nofollow = (typeof options.follow === 'boolean' ? !options.follow : false)
  var etag = options.etag
  var what = options.body

  var parsed = url.parse(uri)

  var where = parsed.pathname
  if (parsed.search) {
    where = where + parsed.search
    parsed.search = ''
  }
  parsed.pathname = '/'

  var registry = url.format(parsed)

  // Since there are multiple places where an error could occur,
  // don't let the cb be called more than once.
  var errState = null
  function cb (er) {
    if (errState) return
    if (er) errState = er
    cb_.apply(null, arguments)
  }

  // resolve to a full url on the registry
  if (!where.match(/^https?:\/\//)) {

    var q = where.split('?')
    where = q.shift()
    q = q.join('?')

    if (where.charAt(0) !== '/') where = '/' + where
    where = '.' + where.split('/').map(function (p) {
      p = p.trim()
      return encodeURIComponent(p)
    }).join('/')
    if (q) where += '?' + q
    where = url.resolve(registry, where)
  }

  var remote = url.parse(where);

  var self = this
  makeRequest.call(self, method, remote, where, what, etag, nofollow
                   , function (er, parsed, raw, response) {
    if (!er || (er.message && er.message.match(/^SSL Error/))) {
      if (er)
        er.code = 'ESSL'
      return cb(er, parsed, raw, response)
    }

    // Only retry on 408, 5xx or no `response`.
    var statusCode = response && response.statusCode

    var timeout = statusCode === 408
    var serverError = statusCode >= 500
    var statusRetry = !statusCode || timeout || serverError
    if (er) {
      throw er;
    }
    cb.apply(null, arguments)
  }.bind(this))
}

function makeRequest (method, remote, where, what, etag, nofollow, cb_) {
  var cbCalled = false
  function cb () {
    if (cbCalled) return
    cbCalled = true
    cb_.apply(null, arguments)
  }

  var opts = { url: remote
             , method: method
             , encoding: null // tell request let body be Buffer instance
             }
    , headers = opts.headers = {};

  if (etag) {
    headers[method === 'GET' ? 'if-none-match' : 'if-match'] = etag;
  }

  headers.accept = 'application/json';
  headers['accept-encoding'] = 'gzip';

  headers['user-agent'] = 'BuildClient v' + this.version + ' node/' + process.version;

  // figure out wth 'what' is
  if (what) {
    if (Buffer.isBuffer(what) || typeof what === 'string') {
      opts.body = what;
      headers['content-type'] = 'application/json';
      headers['content-length'] = Buffer.byteLength(what);
    } else if (what instanceof Stream) {
      headers['content-type'] = 'application/octet-stream';
      if (what.size) headers['content-length'] = what.size;
    } else {
      delete what._etag;
      opts.json = what;
    }
  }

  if (nofollow) {
    opts.followRedirect = false;
  }

  var done = requestDone.call(this, method, where, cb);
  var req = request(opts, decodeResponseBody(done));

  req.on('error', cb);
  req.on('socket', function (s) {
    s.on('error', cb);
  });

  if (what && (what instanceof Stream)) {
    what.pipe(req);
  }
}

function decodeResponseBody(cb) {
  return function (er, response, data) {
    if (er) return cb(er, response, data);

    // don't ever re-use connections that had server errors.
    // those sockets connect to the Bad Place!
    if (response.socket && response.statusCode > 500) {
      response.socket.destroy();
    }

    if (response.headers['content-encoding'] !== 'gzip') return cb(er, response, data);

    zlib.gunzip(data, function (er, buf) {
      if (er) return cb(er, response, data);

      cb(null, response, buf);
    });
  }
}

// cb(er, parsed, raw, response)
function requestDone (method, where, cb) {
  return function (er, response, data) {
    if (er) return cb(er);

    var urlObj = url.parse(where);
    if (urlObj.auth)
      urlObj.auth = '***';

    var parsed;

    if (Buffer.isBuffer(data)) {
      data = data.toString();
    }

    if (data && typeof data === 'string' && response.statusCode !== 304) {
      try {
        parsed = JSON.parse(data);
      } catch (ex) {
        ex.message += '\n' + data;
        console.log('Bad json => ' + data);
        return cb(ex, null, data, response);
      }
    } else if (data) {
      parsed = data;
      data = JSON.stringify(parsed);
    }

    // expect data with any error codes
    if (!data && response.statusCode >= 400) {
      return cb( response.statusCode + ' '
               + require('http').STATUS_CODES[response.statusCode]
               , null, data, response );
    }

    er = null;
    if (parsed && response.headers.etag) {
      parsed._etag = response.headers.etag;
    }

    if (parsed && parsed.error && response.statusCode >= 400) {
      var w = url.parse(where).pathname.substr(1);
      var name;
      if (!w.match(/^-/) && parsed.error === 'not_found') {
        w = w.split('/');
        name = w[w.indexOf('_rewrite') + 1];
        er = new Error('404 Not Found: '+name);
        er.code = 'E404';
        er.pkgid = name;
      } else {
        er = new Error(
          parsed.error + ' ' + (parsed.reason || '') + ': ' + w);
      }
    } else if (method !== 'HEAD' && method !== 'GET') {
      // invalidate cache
      // This is irrelevant for commands that do etag caching, but
      // ls and view also have a timed cache, so this keeps the user
      // from thinking that it didn't work when it did.
      // Note that failure is an acceptable option here, since the
      // only result will be a stale cache for some helper commands.
    }
    return cb(er, parsed, data, response);
  }.bind(this);
}
